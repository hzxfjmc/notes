# 网页安全

网页安全问题是一个在开发中应该极其注重的问题。

# Navigator

* [同源策略](#同源策略)

* [XSS](#XSS)

* [CSRF](#CSRF)

* [SQL注入](#SQL注入)

* [点击劫持](#点击劫持)

* [window.opener安全问题](#window.opener安全问题)

* [文件上传漏洞](#文件上传漏洞)


## 同源策略

同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另外一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。同源策略是浏览器为了安全而做出的一种安全策略

原理：如果两个URL的协议、域名、端口都一致的话那么他们就是同源，相反就是不同源会有跨域问题

### 同原协议的问题

* 同源策略限制了不同的JavaScript脚本对当前Dom对象的读写操作

* 同源策略限制了不同源的站点读取当前站点的Cookie、IndexDB、localStorage等重要数据。

* 同源策略限制了通过XMLHttpRequest等方式将站点的数据发送不同源的站点

### 解决同源策略的方法

* 跨文档消息机制：可以通过window.postMessage的JavaScript接口来和不同源的DOM进行通信

* 跨域资源共享（CORS）：跨域资源在服务器设置允许跨域，就可以进行跨域访问控制，从而使跨域数据传输得以安全进行

* 内容安全策略（CSP）:主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包括JS、CSS、image等等），而非白名单的内容无法正常执行

## XSS
XSS也叫跨脚本攻击，是最普遍的Web应用安全漏洞。共有两种攻击模式
### 存储型XSS攻击
利用漏洞提交恶意的JavaScript代码，比如在input、textarea等所有的可输入文本信息的区域，输入<script src="http://恶意网站"></script>等、提交活信息会存在服务器中，当用户打开网站请求到相应的数据，打开页面，恶意脚本就会将用户的Cookie信息上传到黑客服务器。

### 反射型XSS攻击
用户将一段含有恶意代码的请求提交给web服务器，web服务器接收请求时。又将恶意代码反射给浏览器。这就是反射型XSS攻击。我们经常遇到的黑客通过QQ群或者邮件等渠道去诱导用户点击这些恶意链接。

    这两种攻击方式的不同是。反射型攻击不会存储在服务上。存储型攻击会存储在服务器上

### 基于DOM的XSS攻击

基于DOM的XSS攻击不设计到服务器。它的特点是在Web资源传输过程中或者在用户使用页面过程中修改web页面的数据。比如数据劫持

### 预防策略

1、讲cookie等敏感信息设置为httponly。禁止JavaScript通过document.cookie获取

2、对所有的输入做严格的校验，尤其是服务器端。过滤掉任何不合法的输入，比如手机号码必须是数字。

3、净化和过滤掉不必要的html标签。比如img的img、script、iframe、等可输入型标签

4、转义单引号、双引号、尖括号等特殊字符，可以采用htmlencode编码或者过滤掉这些特殊字符。

5、CSP,CSP 全称为 Content Security Policy，即内容安全策略。主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等等），而非白名单的内容无法正常执行，从而减少跨站脚本攻击（XSS）

## CSRF攻击
CSRF攻击也叫跨站伪请求，引诱用户打开黑客提前准备好的网站，利用用户的登录状态去发起跨站请求
发起CSRF攻击的三个必要条件

1、目标站点一定有CSRF漏洞  
2、用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态  
3、需要用户打开一个第三方站点，如黑客的站点等。  

预防策略：  
1、充分利用好Cookie的sameSite属性
SameSite的选项通常有Strict、Lax和None三个值  

    1、Strict值，那么浏览器完全禁止第三方Cookie  
    2、Lax相对来说宽松一点，在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交的Get方式的表单这两种方式会携带Cookie。但在第三方站点中使用Post方法，或者通过img、iframe、等标签加载的URL，这些场景都不会携带cookie  
    3、使用none的话，在任何情况下都会发送Cookie数据

    set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none

2、验证请求的来源网点    

    在服务器验证请求来源的站点，就是验证http请求头中的origin和Referer属性。Referer是Http请求头中的一个字段，记录了该Http请求的来源地址，而origin属性只包含了域名信息，并没有包括URL完整路径，这是origin和Referfer的主要区别
 
3、在请求头中添加token并验证

    CSRF攻击之所有能够成功，是因为黑客可以完全伪造用户请求，该请求中所有用户验证的信息都是存在cookie中，因此黑客可以在不知道这些验证信息的情况直接利用用户自己的cookie来通过安全验证。因此要抵御CSRF，关键在于请求中放入黑客所不能伪造的信息，并且该请求不存在与cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token的合法性。

4、在HTTP头中自定义属性并验证   
 
    这种方法也是使用token并进行验证，和上一种方法不同的，这里并不是把token以参数的形式置于http请求中，而是把它放到http头中自定义属性里。


## 文件上传漏洞

服务器未校验上传的文件，致使黑客可以上传恶意脚本等方式  

预防策略   

    1、用文件头来检测文件类型，使用白名单过滤（有些文件可以从其中一部分执行，只检查文件头无效，例如PHP等脚本语言）
    
    2、上传后将文件彻底重命名并移到不可执行的目录下

    3、升级服务器软件以避免路径解析漏洞

    4、升级用到的开源编辑器

    5、管理后台设置强密码